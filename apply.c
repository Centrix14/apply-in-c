/*
  Внимание, следующий далее код может вызвать:
  1. Внезапные спышки гнева, депрессии, апатии и диреализации.
  2. Непреодолимое желание крушить всё вокруг.
  3. Рвоту, желчевыделение и диарею.

  Будьте осторожны: если после прочтения вы гуглите "как съехать с Земли", то это
  верный признак слабости. Остановитесь!

  Так о чём я? Да. Можно ли в Си реализовать что-то вроде лиспового apply? Этим
  вопросом я задаюсь давно. Вот сегодня он снова начал интересовать меня.
  Оказывается, что-то подобное уже реализовали: https://www.dyncall.org/

  Но я был бы не я, если бы не взялся написать что-то своё. И нечто у меня
  получилось. Нечто ужасное. Но вместе с тем оно завораживает меня. Если вы всё
  ещё тут, то давайте я вам расскажу как всё работает.
 */

#include <stdio.h>

// Вот этот урод нужен мне чтобы не вычислять длину массива вручную
#define alen(type, array) sizeof(array) / sizeof(type)

// А этот просто для того, чтобы в финале записать apply красиво, и конечно,
// не безопасно
#define _(f, t, args) apply(f, (T)args, alen(t, args))

// Я знаю, что в Си не принято так делать, но почему бы нет? Обобщённый указатель
// это T, а обобщённая функция - F
typedef void* T;
typedef T (*F)();

// Далее следует часть очень скучная: обёртки, которые преобразуют массив в
// список аргументов. Здесь приведено всего 4 обёртки, но при желании, можно
// добавить и больше. Можно даже генератор таких функций написать. Всё можно!
T apply_1(F f, T args[1]) {
    return (f)(args[0]);
}

T apply_2(F f, T args[2]) {
    return (f)(args[0], args[1]);
}

T apply_3(F f, T args[3]) {
    return (f)(args[0], args[1], args[2]);
}

T apply_4(F f, T args[4]) {
    return (f)(args[0], args[1], args[2], args[3]);
}

// Если есть обёртки для конкретного числа аргументов, значит есть и функция,
// которая собирает всё вместе.
// Здесь вы можете сказать: но постой, у тебя же всё передаётся в T, т. е.
// обобщённо. Как же должны работать функции, которые мы вызываем, например,
// sqrt из math.h? Да вот никак. Я пока не знаю как написать переводчик типов.
// Поэтому всё описанное будет работать только с функциями, которые изначально
// заданы для значений типа T. Эти функции я далее буду называть упоротыми.
T apply(F f, T args[], int len) {
    F funcs[] = {apply_1, apply_2, apply_3, apply_4};
    
    return (funcs[len])(f, args);
}

// Ну и для демонстрации того, что всё работает, две упоротые функции. Первая -
// типичный для лиспера quote.
T quote(T arg) {
    return arg;
}

// Ну и каноническое сложение чисел, куда же без него?..
int add(T x, T y) {
    int rx = *(int*)x;
    int ry = *(int*)y;
    
    return rx + ry;
}

int main(void) {
    int one = 1, two = 2;
    int *args[] = {&one, &two};

    // Ну и так всё это непотребство выглядит на практике.
    // С рабоче-крестьянским apply:
    T call1 = apply((F)add, (T)args, alen(int*, args));

    // И так с тем самым пижонским макросом:
    T call2 = _((F)add, int**, args);

    // Что удивительно, все эти трюки с вызовами и приведениями типов работают.
    printf("%u = %u\n", call1, call2);

    // Вообще, printf - универсальный приводитель типов. Надо использовать эту
    // идею. Ещё, я знаю, что где-то нарушил strict aliasing, но не плевать ли?
    // Работает - и славно!
    
    return 0;
}
